import React, { useState, useEffect } from 'react';

// Ethers.js is loaded via a script tag in the HTML wrapper.
// We access it via `window.ethers`.

// Helper function to decode input data using a given ABI
const decodeInputWithABI = (input, abis) => {
  if (!input || typeof input !== 'string' || input.length < 10 || !window.ethers) {
    return null;
  }

  const iface = new window.ethers.utils.Interface(abis);
  
  try {
    const decoded = iface.parseTransaction({ data: input });
    if (decoded) {
      // Decode parameters to a readable format
      const decodedParameters = {};
      decoded.args.forEach((arg, index) => {
        const paramName = decoded.functionFragment.inputs[index].name || `param${index}`;
        let paramValue = arg;
        if (window.ethers.BigNumber.isBigNumber(arg)) {
          paramValue = arg.toString();
        } else if (Array.isArray(arg)) {
            // Handle arrays of parameters
            paramValue = arg.map(item => window.ethers.BigNumber.isBigNumber(item) ? item.toString() : item);
        }
        decodedParameters[paramName] = paramValue;
      });
      return {
        functionName: decoded.name,
        functionSignature: decoded.functionFragment.format(),
        decodedParameters: decodedParameters,
      };
    }
  } catch (err) {
    console.error("Failed to decode with ABI:", err);
  }

  return null;
};

// Helper function to decode logs using a given ABI
const decodeLogsWithABI = (logs, abis) => {
  if (!logs || !window.ethers) {
    return [];
  }
  const iface = new window.ethers.utils.Interface(abis);
  const decodedLogs = [];

  logs.forEach(log => {
    try {
      const parsedLog = iface.parseLog(log);
      if (parsedLog) {
        const decodedArgs = {};
        parsedLog.args.forEach((arg, index) => {
          const paramName = parsedLog.eventFragment.inputs[index].name || `arg${index}`;
          let paramValue = arg;
          if (window.ethers.BigNumber.isBigNumber(arg)) {
            paramValue = arg.toString();
          } else if (Array.isArray(arg)) {
              paramValue = arg.map(item => window.ethers.BigNumber.isBigNumber(item) ? item.toString() : item);
          }
          decodedArgs[paramName] = paramValue;
        });
        decodedLogs.push({
          eventName: parsedLog.name,
          eventSignature: parsedLog.eventFragment.format(), // Add the full event signature
          address: log.address,
          logIndex: parseInt(log.logIndex, 16), // Convert hex logIndex to a decimal number
          topics: log.topics, // Add the raw topics to the decoded log object
          args: decodedArgs, // Pass the arguments as a structured object, not a string
          isDecoded: true,
        });
      }
    } catch (err) {
      // If decoding fails, add the raw log to the list with a flag
      decodedLogs.push({
        address: log.address,
        logIndex: parseInt(log.logIndex, 16),
        topics: log.topics,
        data: log.data,
        isDecoded: false,
      });
      console.warn("Could not decode log:", log, err);
    }
  });

  return decodedLogs;
};


// Main application component
export default function App() {
  // State variables for the transaction hash, RPC URL, and transaction data
  const [txHash, setTxHash] = useState('0xf832242070b1f28a9af8b22ec168e898de75eb3723bac2dc3924d0e6cf615a08');
  const [rpcUrl, setRpcUrl] = useState('https://rpc-pulsechain.g4mm4.io');
  const [transactionData, setTransactionData] = useState(null);
  const [structuredTransactionData, setStructuredTransactionData] = useState(null);
  const [transactionReceipt, setTransactionReceipt] = useState(null);
  const [structuredTransactionReceipt, setStructuredTransactionReceipt] = useState(null);
  const [decodedInputData, setDecodedInputData] = useState(null);
  const [decodedLogs, setDecodedLogs] = useState([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);
  const [isEthersReady, setIsEthersReady] = useState(false);
  const [showStructuredView, setShowStructuredView] = useState(true);

  // Load ethers.js from a CDN
  useEffect(() => {
    if (window.ethers) {
        setIsEthersReady(true);
        return;
    }
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js';
    script.onload = () => {
        setIsEthersReady(true);
        console.log("Ethers.js loaded from CDN.");
    };
    script.onerror = () => {
        setError("Failed to load ethers.js library. Please try again.");
    };
    document.body.appendChild(script);
    
    return () => {
        document.body.removeChild(script);
    };
  }, []);

  // ABIs for common contracts
  const erc20ABI = [
    "function approve(address spender, uint256 amount) public returns (bool)",
    "function transfer(address to, uint256 amount) public returns (bool)",
    "function transferFrom(address from, address to, uint256 amount) public returns (bool)",
    // Added event for log decoding
    "event Transfer(address indexed from, address indexed to, uint256 value)"
  ];
  
  // ABIs for Uniswap V2 Routers (functions) and Pairs (events)
  const uniswapv2ABI = [
    "function swapExactETHForTokens(uint256 amountOutMin, address[] path, address to, uint256 deadline) external payable returns (uint256[] memory amounts)",
    "function swapExactTokensForTokens(uint256 amountIn, uint256 amountOutMin, address[] path, address to, uint256 deadline) external returns (uint256[] memory amounts)",
    "function addLiquidityETH(address token, uint256 amountTokenDesired, uint256 amountTokenMin, uint256 amountETHMin, address to, uint256 deadline) external payable returns (uint256 amountToken, uint256 amountETH, uint256 liquidity)",
    // Added Uniswap V2 Pair events for log decoding
    "event Swap(address indexed sender, uint256 amount0In, uint256 amount1In, uint256 amount0Out, uint256 amount1Out, address indexed to)",
    "event Mint(address indexed sender, uint256 amount0, uint256 amount1)",
    "event Burn(address indexed sender, uint256 amount0, uint256 amount1, address indexed to)",
    "event Sync(uint112 reserve0, uint112 reserve1)"
  ];
  
  const allABIs = [...erc20ABI, ...uniswapv2ABI];

  // useEffect hook to decode the input data whenever transactionData changes
  useEffect(() => {
    if (isEthersReady && transactionData && transactionData.input && transactionData.input !== '0x') {
      const decoded = decodeInputWithABI(transactionData.input, allABIs);
      setDecodedInputData(decoded);
    } else {
      setDecodedInputData(null);
    }
  }, [transactionData, allABIs, isEthersReady]);

  // useEffect hook to decode logs whenever transactionReceipt changes
  useEffect(() => {
    if (isEthersReady && transactionReceipt && transactionReceipt.logs) {
      const decoded = decodeLogsWithABI(transactionReceipt.logs, allABIs);
      setDecodedLogs(decoded);
    } else {
      setDecodedLogs([]);
    }
  }, [transactionReceipt, allABIs, isEthersReady]);

  // Async function to fetch both transaction data and the receipt from the blockchain RPC
  const fetchTransactionData = async () => {
    // Reset all states and show loading indicator
    setLoading(true);
    setTransactionData(null);
    setStructuredTransactionData(null);
    setTransactionReceipt(null);
    setStructuredTransactionReceipt(null);
    setDecodedInputData(null);
    setDecodedLogs([]);
    setError(null);

    // Basic validation
    if (!txHash || !rpcUrl) {
      setError('Please enter a valid transaction hash and RPC URL.');
      setLoading(false);
      return;
    }
    
    if (!isEthersReady) {
        setError('Ethers.js is not loaded yet. Please wait a moment and try again.');
        setLoading(false);
        return;
    }

    try {
      // Step 1: Fetch the raw transaction data
      const txRequestBody = {
        jsonrpc: '2.0',
        method: 'eth_getTransactionByHash',
        params: [txHash],
        id: 1,
      };

      let txResponse = await fetch(rpcUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(txRequestBody),
      });

      if (!txResponse.ok) {
        throw new Error(`HTTP error! status: ${txResponse.status}`);
      }

      let txData = await txResponse.json();
      if (txData.result) {
        setTransactionData(txData.result);
        // Create structured version for display
        const structuredTxData = {
          from: txData.result.from,
          to: txData.result.to,
          value: window.ethers.utils.formatEther(txData.result.value) + ' ETH',
          gasPrice: parseInt(txData.result.gasPrice, 16) + ' wei',
          nonce: parseInt(txData.result.nonce, 16),
          blockNumber: parseInt(txData.result.blockNumber, 16),
          type: parseInt(txData.result.type, 16) === 0 ? 'Legacy' : 'EIP-1559',
          // Exclude input data from structured view
        };
        setStructuredTransactionData(structuredTxData);
      } else {
        setError(txData.error ? txData.error.message : 'Transaction not found or invalid response for getTransactionByHash.');
      }
      
      // Step 2: Fetch the raw transaction receipt
      const receiptRequestBody = {
        jsonrpc: '2.0',
        method: 'eth_getTransactionReceipt',
        params: [txHash],
        id: 2,
      };

      let receiptResponse = await fetch(rpcUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(receiptRequestBody),
      });

      if (!receiptResponse.ok) {
        throw new Error(`HTTP error! status: ${receiptResponse.status}`);
      }

      let receiptData = await receiptResponse.json();
      if (receiptData.result) {
        setTransactionReceipt(receiptData.result);
        
        // Calculate the transaction fee
        const gasUsed = window.ethers.BigNumber.from(receiptData.result.gasUsed);
        const effectiveGasPrice = window.ethers.BigNumber.from(receiptData.result.effectiveGasPrice);
        const transactionFee = window.ethers.utils.formatEther(gasUsed.mul(effectiveGasPrice));

        // Create structured version for display, excluding logs
        const structuredReceiptData = {
          transactionHash: receiptData.result.transactionHash,
          transactionIndex: parseInt(receiptData.result.transactionIndex, 16),
          status: parseInt(receiptData.result.status, 16) === 1 ? 'Success' : 'Failed',
          gasUsed: parseInt(receiptData.result.gasUsed, 16) + ' units',
          effectiveGasPrice: parseInt(receiptData.result.effectiveGasPrice, 16) + ' wei',
          transactionFee: `${transactionFee} ETH`,
          contractAddress: receiptData.result.contractAddress || 'N/A',
        };
        setStructuredTransactionReceipt(structuredReceiptData);
      } else {
        setError(receiptData.error ? receiptData.error.message : 'Transaction receipt not found or invalid response.');
      }

    } catch (err) {
      // Catch any network or parsing errors
      setError(`Failed to fetch data: ${err.message}`);
    } finally {
      // Hide the loading indicator
      setLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-100 dark:bg-gray-900 text-gray-900 dark:text-gray-100 p-8 flex flex-col items-center justify-center font-sans">
      <div className="w-full max-w-2xl bg-white dark:bg-gray-800 p-8 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700">
        <div className="mb-4">
          <label htmlFor="rpcUrl" className="block text-sm font-medium mb-1">
            RPC URL
          </label>
          <input
            type="text"
            id="rpcUrl"
            className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-200"
            value={rpcUrl}
            onChange={(e) => setRpcUrl(e.target.value)}
            placeholder="e.g., https://mainnet.infura.io/v3/..."
          />
        </div>

        <div className="mb-6">
          <label htmlFor="txHash" className="block text-sm font-medium mb-1">
            Transaction Hash
          </label>
          <input
            type="text"
            id="txHash"
            className="w-full p-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-gray-200"
            value={txHash}
            onChange={(e) => setTxHash(e.target.value)}
            placeholder="e.g., 0x..."
          />
        </div>

        <button
          onClick={fetchTransactionData}
          disabled={loading || !isEthersReady}
          className="w-full py-3 px-4 rounded-lg text-white font-semibold transition-all duration-300
                     bg-blue-600 hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-500/50
                     dark:bg-blue-500 dark:hover:bg-blue-600 dark:focus:ring-blue-400/50
                     disabled:bg-gray-400 disabled:cursor-not-allowed"
        >
          {loading ? 'Fetching...' : isEthersReady ? 'Fetch Transaction Data & Receipt' : 'Loading Libraries...'}
        </button>

        {error && (
          <div className="mt-4 p-4 bg-red-100 text-red-700 dark:bg-red-900 dark:text-red-300 rounded-lg border border-red-200 dark:border-red-700">
            <p className="font-semibold">Error:</p>
            <p>{error}</p>
          </div>
        )}
      </div>
        
      {/* --- Dynamic Content based on view state --- */}
      {showStructuredView ? (
        <>
          {/* --- Message Section --- */}
          {structuredTransactionData && (
            <div className="w-full max-w-2xl mt-6 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700">
              <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center -m-6 mb-6">
                <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200">Message</h3>
              </div>
              <div className="space-y-1">
                {Object.entries(structuredTransactionData).map(([key, value]) => (
                  <div key={key} className="flex items-start bg-gray-100 dark:bg-gray-800 p-1.5 rounded border border-gray-200 dark:border-gray-700">
                    <span className="text-gray-500 dark:text-gray-400 w-28 flex-shrink-0">{key}:</span>
                    <code className="font-mono text-gray-800 dark:text-gray-200 break-all ml-2">
                      {typeof value === 'object' ? JSON.stringify(value) : value}
                    </code>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* --- Input Section --- */}
          {decodedInputData && (
            <div className="w-full max-w-2xl mt-6 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700">
              <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center -m-6 mb-6">
                <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200">Input</h3>
              </div>
              <div className="text-sm">
                <p className="font-medium text-gray-600 dark:text-gray-400">Function Call:</p>
                <code className="block bg-gray-100 dark:bg-gray-700 p-2 rounded border border-gray-200 dark:border-gray-600 text-gray-800 dark:text-gray-200 font-mono text-xs overflow-x-auto">
                  {decodedInputData.functionSignature}
                </code>
              </div>
              <div className="text-sm mt-4">
                <p className="font-medium text-gray-600 dark:text-gray-400 mb-1">Parameters:</p>
                <div className="space-y-1">
                  {Object.entries(decodedInputData.decodedParameters).map(([key, value]) => (
                    <div key={key} className="flex items-start bg-gray-100 dark:bg-gray-800 p-1.5 rounded border border-gray-200 dark:border-gray-700">
                      <span className="text-gray-500 dark:text-gray-400 w-24 flex-shrink-0">{key}:</span>
                      <code className="font-mono text-gray-800 dark:text-gray-200 break-all ml-2">
                        {typeof value === 'object' ? JSON.stringify(value) : value}
                      </code>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}

          {/* --- Receipt Section --- */}
          {structuredTransactionReceipt && (
            <div className="w-full max-w-2xl mt-6 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700">
              <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center -m-6 mb-6">
                <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200">Receipt</h3>
              </div>
              <div className="space-y-1">
                {Object.entries(structuredTransactionReceipt).map(([key, value]) => (
                  <div key={key} className="flex items-start bg-gray-100 dark:bg-gray-800 p-1.5 rounded border border-gray-200 dark:border-gray-700">
                    <span className="text-gray-500 dark:text-gray-400 w-36 flex-shrink-0">{key}:</span>
                    <code className="font-mono text-gray-800 dark:text-gray-200 break-all ml-2">
                      {typeof value === 'object' ? JSON.stringify(value) : value}
                    </code>
                  </div>
                ))}
              </div>
            </div>
          )}

          {/* --- Logs Section --- */}
          {decodedLogs.length > 0 && (
            <div className="w-full max-w-2xl mt-6 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700">
              <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center -m-6 mb-6">
                <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200">Event Logs ({decodedLogs.length})</h3>
              </div>
              {decodedLogs.map((log, index) => (
                <div key={index} className="border border-gray-200 dark:border-gray-700 rounded-lg overflow-hidden mb-4 last:mb-0">
                  {/* Log Header */}
                  <div className="bg-gray-50 dark:bg-gray-700 px-3 py-2 flex items-center space-x-2 border-b border-gray-200 dark:border-gray-600">
                    <span className="inline-flex items-center justify-center px-2 py-0.5 text-xs font-bold leading-none text-indigo-100 bg-indigo-700 rounded-full">
                      {log.logIndex}
                    </span>
                    <span className="text-sm font-semibold text-indigo-800 dark:text-indigo-200">
                      {log.isDecoded ? log.eventSignature : "Undecodable Log"}
                    </span>
                  </div>
                  {/* Log Body */}
                  <div className="p-3 text-xs space-y-2 bg-white dark:bg-gray-800">
                    {/* Address */}
                    <div className="flex items-start">
                      <span className="font-medium text-gray-500 dark:text-gray-400 w-20 flex-shrink-0">Address:</span>
                      <a className="text-blue-600 dark:text-blue-400 hover:underline font-mono break-all ml-2" href="#">
                        {log.address}
                      </a>
                    </div>
                    {/* Topics */}
                    <div className="flex items-start">
                      <span className="font-medium text-gray-500 dark:text-gray-400 w-20 flex-shrink-0">Topics:</span>
                      <div className="ml-2 space-y-1 w-full">
                        {log.topics.map((topic, topicIndex) => (
                          <div key={topicIndex} className="flex items-center">
                            <span className="text-gray-400 dark:text-gray-500 mr-2">{topicIndex}:</span>
                            <code className="font-mono text-gray-800 dark:text-gray-200 break-all bg-gray-100 dark:bg-gray-700 px-1 rounded border border-gray-200 dark:border-gray-600 w-full overflow-x-auto">
                              {topic}
                            </code>
                          </div>
                        ))}
                    </div>
                  </div>
                    {/* Parameters / Raw Data */}
                    {log.isDecoded ? (
                      <div className="flex items-start">
                        <span className="font-medium text-gray-500 dark:text-gray-400 w-20 flex-shrink-0">Params:</span>
                        <div className="ml-2 space-y-1 w-full">
                          {Object.entries(log.args).map(([key, value], paramIndex) => (
                            <div key={paramIndex} className="flex items-start bg-gray-100 dark:bg-gray-700 p-1 rounded border border-gray-200 dark:border-gray-600">
                              <span className="text-gray-500 dark:text-gray-400 w-16 flex-shrink-0">{key}:</span>
                              <code className="font-mono text-gray-800 dark:text-gray-200 break-all ml-2">
                                {typeof value === 'object' ? JSON.stringify(value, null, 2) : value}
                              </code>
                            </div>
                          ))}
                        </div>
                      </div>
                    ) : (
                      <div className="flex items-start">
                        <span className="font-medium text-gray-500 dark:text-gray-400 w-20 flex-shrink-0">Data:</span>
                        <code className="font-mono text-gray-800 dark:text-gray-200 break-all bg-gray-100 dark:bg-gray-700 px-1 rounded border border-gray-200 dark:border-gray-600 w-full overflow-x-auto ml-2">
                          {log.data}
                        </code>
                    </div>
                    )}
                </div>
                </div>
              ))}
            </div>
          )}
        </>
      ) : (
        <>
          {/* --- Raw Transaction Data Section --- */}
          {transactionData && (
            <div className="w-full max-w-2xl mt-6 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700">
              <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center -m-6 mb-6">
                <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200">Message</h3>
              </div>
              <div className="bg-gray-50 dark:bg-gray-900 rounded-lg p-4 overflow-x-auto border border-gray-200 dark:border-gray-700 shadow-inner">
                <pre className="text-sm">
                  <code>
                    {JSON.stringify(transactionData, null, 2)}
                  </code>
                </pre>
              </div>
            </div>
          )}

          {/* --- Raw Transaction Receipt Section --- */}
          {transactionReceipt && (
            <div className="w-full max-w-2xl mt-6 bg-white dark:bg-gray-800 p-6 rounded-xl shadow-2xl border border-gray-200 dark:border-gray-700">
              <div className="px-4 py-3 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center -m-6 mb-6">
                <h3 className="text-lg font-semibold text-gray-700 dark:text-gray-200">Receipt</h3>
              </div>
              <div className="bg-gray-50 dark:bg-gray-900 rounded-lg p-4 overflow-x-auto border border-gray-200 dark:border-gray-700 shadow-inner">
                <pre className="text-sm">
                  <code>
                    {JSON.stringify(transactionReceipt, null, 2)}
                  </code>
                </pre>
              </div>
            </div>
          )}
        </>
      )}

      {/* --- View Control Button --- */}
      {(structuredTransactionData || transactionData) && (
        <div className="w-full max-w-2xl mt-6">
          <button
            onClick={() => setShowStructuredView(!showStructuredView)}
            className="w-full py-3 px-4 rounded-lg text-white font-semibold transition-all duration-300
                        bg-gray-600 hover:bg-gray-700 focus:outline-none focus:ring-4 focus:ring-gray-500/50
                        dark:bg-gray-500 dark:hover:bg-gray-600 dark:focus:ring-gray-400/50"
          >
            {showStructuredView ? 'Switch to Raw View' : 'Switch to Structured View'}
          </button>
        </div>
      )}
    </div>
  );
}
